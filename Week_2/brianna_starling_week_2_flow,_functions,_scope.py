# -*- coding: utf-8 -*-
"""Brianna Starling - WEEK 2: Flow, Functions, Scope.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nAXpJz7AlNRX6bxWdZ8J4SDvTcoWGuKs

Add your name here: [Brianna Starling]
"""

# update name variable with your name and run cell
name = "Brianna Starling"
print("This notebook belongs to", name)

"""#Background Info-------------------------------------------------------
## A quick note on Comments
In Python, a way for you to write notes in the middle of a python code/script is through the use of comments. Comments are colored green in colab and are marked by a hashtag at the start of the line. Comments are not executed by the python interpreter and because of that are good for leaving notes.

##Functions

We use functions when we notice that there is a snippet of code that we use a lot. Functions are great for reusability - once a function is defined you can use it over and over again. 

It is important to understand all the components of a function in Python.

1.   Function header
2.   Function body
3.   Function call

Below are a few examples and before each example is a 'function contract' where the function definition, parameters, return type, and call are described.

####**Run the code cells and see how the output changes when you uncomment the indicated lines of code**
"""

# Definition   : function name is "hello_world()" and it prints "Hello, World!"
# Parameters   : function takes no parameters (parantheses are empty)
# Return Type  : function returns nothing - it only prints
# Function call: function is called by using its name "hello_world" 
def hello_world():
  print("Hello, World!")

# Remove the hashtag from lines below one at a time and see what changes--------
hello_world()
print("Hello, World!")
#print("hello_world()")

# Definition   : function name is "evaluate cube(number)" and it multiplies its
#                parameter, number, by itself three times
# Parameters   : function takes one parameter, assumably an integer or float
# Return Type  : returns 'result', which is an integer or float
# Function call: function is called by using its name and giving it a parameter
#                which will be assigned to variable 'number' inside the function
def evaluate_cube(number):
  result = number * number * number
  return result

# Remove the hashtags from lines below one at a time and see what changes-------
print(evaluate_cube(3))
print(type(evaluate_cube))
print(type(evaluate_cube(3)))

def eval_cube(num):
  result = num * num * num
  print(result)

eval_cube(3)

def concatenate(string_one, string_two):
  result = string_one + string_two
  return result
  
your_name  = "Brianna" # insert your name in the double quotes
megastring = concatenate("Hi, ","my name is ") + your_name
print(megastring)

"""### Fruitful Functions versus Void Functions

Remember that functions which use the 'return' keyword are considered fruitful functions - that is, they return a value. Void functions do not use the return keyword (which tells the Python interpreter to return a value) and thus, don't return anything. The way Python indicates this is by having void functions return 'None'. A special return type which just indicates the function returns nothing and is void!

### Answer these questions...

1.   Write the function contracts for eval_cube() and concatenate()
2.   What are some of the differences between evaluate_cube() and 
eval_cube()?
3.   Why am I able to use concatenate() in the variable megastring as I do?

### Write your answers here:
1. For eval_cube(), the integer or float will be multiplied by itself three times. The concatenate() function, will combine two separate stings. 
2. There seems to be onyl a visual spelling difference between the two. When the functions were given, they seem to perform the same way, as in mutiplying a number by istelf three times.
3. You can use concatenate() in the variable megastring because you are adding two strings together.

## Scope

Try running the code below:
"""

def test_scope():
  local_var = 10

print(local_var)

"""There are three 'regions' or 'namespaces' code can exist in. Each one has a wider area it encompasses. 

1.   **Built-in namespace**: These are built-in functions and keywords such as print() or 'return' which the Python interpreter already knows. You can call them anywhere and the interpreter will recognize them. 

2.   **Global namespace**: These are global variables you might create or variables/functions from an imported library you might call on. You can also call them anywhere and the interpreter will recognize them. The difference here is that they aren't built-in and need to be imported or created.

3.   **Local namespace**: These are regional variables that only exist in small portions of code such as within a function or within a for-loop.

The above code didn't run because the variable 'local_var' exists only within the local namespace of the function body. If you try and call it outside of the function body, the Python interpreter won't recognize it. This is because the space outside of the function body is outside of the local namespace.

#Practice Problems----------------------------------------------------

1. Python has a built-in function called 'len()' which takes a string as a parameter and returns the length of the string. **Write a function** that takes two parameters that are strings and returns the sum of the lengths of the two strings. 

2. There is a library called math which has a ton of useful functions ranging from math.sqrt() to math.factorial() to math.log(). You can find the documentation here: [math module](https://docs.python.org/3/library/math.html). Using math.sqrt(), **write a function** which calculates the hypotenuse of a right triangle given the length of the other two sides. In other words, write a function which performs the Pythagorean Theorem. Return the length of the hypotenuse.

3. What namespace/scope does the len() function come from? What about math.sqrt()?

[Write your answer to number 3 here]


Write your solutions to the coding problems below:
"""

myToDoList   = "laundry + homwork"
hoursOfSleep = "none"
x            = len(myToDoList + hoursOfSleep)
print(x)

def eval_sqrt(num):
  result = num**0.5
  return(result)
x     = 3
y     = 4
sum   = (x**2 + y**2)
hypot = eval_sqrt(sum)
print(hypot)

The function len() is a built-in function. math.sqrt() seems to be built-in as well.